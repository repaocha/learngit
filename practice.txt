>>> cmp(1,2)
-1
>>> cmp(1,1)
0
>>> cmp(2,1)
1
>>> int('123')
123
>>> int('12.34')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '12.34'
>>> int(12.34)
12
>>> exit()

C:\Users\CW\work>python function.py

C:\Users\CW\work>2
'2' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

C:\Users\CW\work>python function.py
  File "function.py", line 1
    def my_abs(10):
                ^
SyntaxError: invalid syntax

C:\Users\CW\work>python
Python 2.7.2 Stackless 3.1b3 060516 (default, Dec 21 2011, 17:08:51) [MSC v.1500 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> my_abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'my_abs' is not defined
>>> def my_abs(x):
... if x >=0:
  File "<stdin>", line 2
    if x >=0:
     ^
IndentationError: expected an indented block
>>> exit()

C:\Users\CW\work>my_abs(10)
'my_abs' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

C:\Users\CW\work>python function.py
  File "function.py", line 1
    def my_abs(10):
                ^
SyntaxError: invalid syntax

C:\Users\CW\work>python function.py

C:\Users\CW\work>my_abs(10)
'my_abs' 不是内部或外部命令，也不是可运行的程序
或批处理文件。

C:\Users\CW\work>python
Python 2.7.2 Stackless 3.1b3 060516 (default, Dec 21 2011, 17:08:51) [MSC v.1500 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> def my_abs(x):
...     if x>=0:
...       return x
...     else:
...       return -x
...
>>> my_abs(10)
10
>>> my_abs(-10）
  File "<stdin>", line 1
    my_abs(-10）
              ^
SyntaxError: invalid syntax
>>> my_abs(-10)
10
>>> my_abs('A')
'A'
>>> abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'str'
>>> def my_abs(x):
...    if not isinstance(x,(int,float)):
...        raise TypeError('bad operand type')
...    if x>=0:
...        return x
...    else:
... return -x
  File "<stdin>", line 7
    return -x
    ^
IndentationError: expected an indented block
>>> def my_abs(x):
...     if not isinstance(x,(int,float)):
...        raise TypeError('bad operand type')
...     if x>=0:
...        return x
...     else:
...        return -x
...
>>> my_abs('A')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in my_abs
TypeError: bad operand type
>>> my_abs(-100)
100
>>> my_abs(100)
100
>>> my_abs(12.34)
12.34
>>> import math
>>>
>>> def move(x,y,step,angle=0):
...     nx=x+step*math.cos(angle)
...     ny=y-step*math.sin(angle)
...     return nx,ny
... x,y=move(100,100,60,math.pi/6)
  File "<stdin>", line 5
    x,y=move(100,100,60,math.pi/6)
    ^
SyntaxError: invalid syntax
>>> x, y = move(100,100,60,math.pi/6)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'move' is not defined
>>> import math
>>>
>>> def move(x,y,step,angle=0):
...     nx=x+step*math.cos(angle)
...     ny=y-step*math.sin(angle)
...     return nx,ny
...
>>> x,y=move(100,100,60,math.pi / 6)
>>> print(x,y)
(151.96152422706632, 70.0)
>>> import math
>>>
>>> def move(x,y,step,angle=0):
...     nx=x+step*math.cos(angle)
...     ny=y-step*math.sin(angle)
...     return nx,ny
...
>>> x,y=move(100,100,60,math.pi/6)
>>> print(x,y)
(151.96152422706632, 70.0)
>>> x, y = move(100,100,60,math.pi/6)
>>> print(x,y)
(151.96152422706632, 70.0)
>>> x,y=move(100,100,60,math.pi/6)
>>> print(x,y)
(151.96152422706632, 70.0)
>>> r=move(100,100,60,math.pi/6)
>>> print(r)
(151.96152422706632, 70.0)
>>> impart math
  File "<stdin>", line 1
    impart math
              ^
SyntaxError: invalid syntax
>>>
>>> import math
>>>
>>> def quadratic(a,b,c):
...    a*x^2+b*x+c=0
...    return x
...
  File "<stdin>", line 2
SyntaxError: can't assign to operator
>>> import math
>>>
>>> def quadratic(a,b,c):
...     if not isinstance(a,(int,float)):
...        raise TypeError('a is not a number')
...     if not isinstance(b,(int,float)):
...        raise TypeError('b is not a number')
...     if not isinstance(c,(int,float)):
...        raise TypeError('c is not a number')
...     p=b*b-4*a*c
...     if p>=0 and a!=0:
...        x1=(b+math.sqrt(p))/(2*a)
...        x2=(-b-math.sqrt(p))/(2*a)
...        return x1,x2
...     else:
...        return('wrong number!')
...
>>> print(quadratic(2.3.1))
  File "<stdin>", line 1
    print(quadratic(2.3.1))
                        ^
SyntaxError: invalid syntax
>>> r=quadratic(2,3,1)
>>> print(r)
(1.0, -1.0)
>>> import math
>>> def quadratic(a,b,c):
...     if not isinstance(a,(int,float)):
...        raise TypeError('a is not a number')
...     if not isinstance(b,(int,float)):
...        raise TypeError('b is not a number')
...     if not isinstance(c,(int,float)):
...        raise TypeError('c is not a number')
...     p=b*b-4*a*c
...     if p>=0 and a!=0:
...        x1=(-b+math.sqrt(p))/(2*a)
...        x1=(-b-math.sqrt(p))/(2*a)
...     if p>=0 and a!=0:
...
  File "<stdin>", line 13

    ^
IndentationError: expected an indented block
>>> import math
>>> def quadratic(a,b,c):
...     if not isinstance(a,(int,float)):
...        raise TypeError('a is not a number')
...     if not isinstance(b,(int,float)):
...        raise TypeError('b is not a number')
...     if not isinstance(c,(int,float)):
...        raise TypeError('c is not a number')
...     p=b*b-4*a*c
...     if p>=0 and a!=0:
...        x1=(-b-math.sqrt(p))/(2*a)
...        x2=(-b+math.sqrt(p))/(2*a)
...        return x1,x2
...     else:
...        return('wrong number!')
...
>>> r=quadratic(2,3,1)
>>> print(r)
(-1.0, -0.5)
>>> import math
>>>
>>> def quadratic(a,b,c):
...     if not isinstance(a,(int,float)):
...        raise TypeError('a is not a number')
...     if not isinstance(b,(int,float)):
...        raise TypeError('b is not a number')
...     if not isinstance(c,(int,float)):
...        raise TypeError('c is not a number')
...     p=b*b-4*a*c
...     if p>=0 and a!=0:
...        x1=(-b+math.sqrt(p))/(2*a)
...        x2=(-b-math.sqrt(p))/(2*a)
...     else:
...        return('wrong number!')
...
>>> r=quadratic(2,3,1)
>>> print(r)
None
>>> import math
>>> def quadratic(a,b,c):
...     if not isinstance(a,(int,float)):
...        raise TypeError('a is not a number')
...     if not isinstance(b,(int,float)):
...        raise TypeError('b is not a number')
...     if not isinstance(c,(int,float)):
...        raise TypeError('c is not a number')
...     p=b*b-4*a*c
...     if p>=0 and a!=0:
...        x1=(-b+math.sqrt(p))/(2*a)
...        x2=(-b-math.sqrt(p))/(2*a)
...        return x1,x2
...     else:
...        return('wrong number!')
...
>>> r=quadratic(2,3,1)
>>> print(r)
(-0.5, -1.0)
>>> import math
>>> def quadratic(a,b,c):
...     if not isinstance(a,(int,float)):
...        raise TypeError('a is not a number')
...     if not isinstance(b,(int,float)):
...        raise TypeError('b is not a number')
...     if not isinstance(c,(int,float)):
...        raise TypeError('c is not a number')
...     p=b^2-4*a*c
...     if p>=0 and a!=0:
...        x1=(-b+math.sqrt(q))/(2*a)
...        x2=(-b-math.sqrt(q))/(2*a)
...        return x1,x2
...     else:
...        return('wrong number!')
...
>>> r=quadratic(2,3,1)
>>> print(r)
wrong number!
>>> def fact(n):
...     return fact_iter(n,1)
... def fact_iter(num,product):
  File "<stdin>", line 3
    def fact_iter(num,product):
      ^
SyntaxError: invalid syntax
>>> def move(n,a,b,c):
...     if n==1:
...        print(a,'-->',c)
...     else:
...        move(n-1,a,c,b)
...        move(1,a,b,c)
...        move(n-1,b,a,c)
... n=input('enter the number:')
  File "<stdin>", line 8
    n=input('enter the number:')
    ^
SyntaxError: invalid syntax
>>> def move(n,a,b,c):
...     if n==1:
...        print(a,'-->',c)
...     else:
...        move(n-1,a,c,b)
...        move(1,a,b,c)
...        move(n-1,b,a,c)
...        n=input('enter the number:')
...        move(int(n),'A','B','C'A)
  File "<stdin>", line 9
    move(int(n),'A','B','C'A)
                           ^
SyntaxError: invalid syntax
>>> def move(n,a,b,c):
...     if n==1:
...        print(a,'-->',c)
...     else:
...        move(n-1,a,c,b)
...        move(1,a,b,c)
...        move(n-1,b,a,c)
...        n=input('enter the number:')
...        move(int(n),'A','B','C')
...
>>> move(3,'A','B','C')
('A', '-->', 'C')
('A', '-->', 'B')
('C', '-->', 'B')
enter the number:3
('A', '-->', 'C')
('A', '-->', 'B')
('C', '-->', 'B')
enter the number:6
('A', '-->', 'B')
('A', '-->', 'C')
('B', '-->', 'C')
enter the number:SER
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in move
  File "<stdin>", line 9, in move
  File "<stdin>", line 5, in move
  File "<stdin>", line 9, in move
  File "<stdin>", line 5, in move
  File "<stdin>", line 5, in move
  File "<stdin>", line 5, in move
  File "<stdin>", line 5, in move
  File "<stdin>", line 8, in move
  File "<string>", line 1, in <module>
NameError: name 'SER' is not defined
>>> def move(n,a,b,c):
...     if n==1:
...        print(a,'-->',c)
...     else:
...        move(n-1,a,c,b)
...        print(a,'-->',c)
...        move(n-1,b,a,c)
...
>>> move(3,a,b,c)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'a' is not defined
>>> move(3,'A','B','C')
('A', '-->', 'C')
('A', '-->', 'B')
('C', '-->', 'B')
('A', '-->', 'C')
('B', '-->', 'A')
('B', '-->', 'C')
('A', '-->', 'C')
>>> move(3,A,B,C)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'A' is not defined
>>> def move(n,a,b,c):
...     if n==1:
...        print('%s --> %s' %(a,c))
...     else:
...        move(n-1,a,c,b)
...        print('%s --> %s' %(a,c))
...        move(n-1,b,a,c)
...
>>> move(3,'A','B','C')
A --> C
A --> B
C --> B
A --> C
B --> A
B --> C
A --> C
>>> def move(n,a,b,c):
...     if n==1:
...        print('%s --> %s' %(a,c))
...     else:
...        move(n-1,a,c,b)
...        print('%s --> %s' %(a,c))
...        move(n-1,b,a,c)
...
>>> move(3,'a','b','c')
a --> c
a --> b
c --> b
a --> c
b --> a
b --> c
a --> c
>>> L=['yang','chen','yangchen','yangyang','yangyangya
ng']
>>> r=[]
>>> n=3
>>> for i in range(n):
...     r.append(L[i])
...
>>> r
['yang', 'chen', 'yangchen']
>>> r=()
>>> n=3
>>> for i in range(n):
...     r.append(L[i])
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
AttributeError: 'tuple' object has no attribute 'appen
d'
>>> L[0:3]
['yang', 'chen', 'yangchen']
>>> L[:3]
['yang', 'chen', 'yangchen']
>>> L[1:3]
['chen', 'yangchen']
>>> L[-2:]
['yangyang', 'yangyangyang']
>>> L=range(100)
>>> l
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'l' is not defined
>>> L
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 2
9, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 5
6, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 8
3, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
 97, 98, 99]
>>> L[1:19]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
, 17, 18]
>>> L[-10:]
[90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
>>> L[:10:2]
[0, 2, 4, 6, 8]
>>> L[::10]
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> L[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 2
9, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 5
6, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 8
3, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,
 97, 98, 99]
>>> L=['ABCDEFGHIJK']
>>> L
['ABCDEFGHIJK']
>>> L[:5]
['ABCDEFGHIJK']
>>> L[::2]
['ABCDEFGHIJK']
>>> 'ABCDEFGHIJK'[:2]
'AB'
>>> L='ABCDEFGHIJK'
>>> L[:2]
'AB'
>>> d={'a':1,'b':2,'c':3}
>>> for key in d:
...     print key
...
a
c
b
>>> for ch in 'ABC':
...     print ch
...
A
B
C
>>> from collections import Iterable
>>> isintance('abc',Iterable)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'isintance' is not defined
>>> from collections import Iterable
>>> isinstance('abc',Iterable)
True
>>> isinstance([1,2,3],Iterable)
True
>>> isinstance(123,Iterable)
False
>>> for i, value in enumerate(['A','B','C']):
...     print i,value
...
0 A
1 B
2 C
>>> for i in('A','B','C'):
...
  File "<stdin>", line 2

    ^
IndentationError: expected an indented block
>>> for i in('A','B','C')
  File "<stdin>", line 1
    for i in('A','B','C')
                        ^
SyntaxError: invalid syntax
>>> for i in('A','B','C'):
...     print i
...
A
B
C
>>> for yang in('abcdefghijklmn):
  File "<stdin>", line 1
    for yang in('abcdefghijklmn):
                                ^
SyntaxError: EOL while scanning string literal
>>> for yang in('abcdefghijk'):
...    print yang
...
a
b
c
d
e
f
g
h
i
j
k
>>> for yangchen in('[1,2,3,4,5,6,7,8,9,0]'):
...     print yangchen
...
[
1
,
2
,
3
,
4
,
5
,
6
,
7
,
8
,
9
,
0
]
>>> for x,y in[(1,1),(2,2),(3,3)]:
...       print x,y
...
1 1
2 2
3 3
>>> for x,y in([1,1],[2,2],[3,3]):
...     print x,y
...
1 1
2 2
3 3

C:\Users\CW>python
Python 2.7.2 Stackless 3.1b3 060516 (default, Dec 21 2011, 17:08:51) [MSC v.1500 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> def cmp_ignore_case(s1,s2):
...     u1=s1.upper()
...     u2=s2.upper()
...     if u1<u2:
...        return -1
...     if u1>u2
  File "<stdin>", line 6
    if u1>u2
           ^
SyntaxError: invalid syntax
>>> def cmp_ignore_case(s1,s2):
...     u1=s1.upper()
...     u2=s2.upper()
...     if u1<u2:
...        return -1
...     if u1>u2:
...        return 1
...     return 0
...
>>> sorted(['Bob','about','Zoo','Credit'],cmp_ignore_case)
['about', 'Bob', 'Credit', 'Zoo']
>>> L=[('Bob',75),('Adam',92),('Bart',66),('Lisa',88)]
>>> def by_name(t):
...     return t[0].lower()
...
>>> L1=sorted(L,key=by_name)
>>> print(L1)
[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]
>>> def cmp_ignore_case(s1,s2):
...     u1=s1.lower()
...     u2=s2.lower()
...     cmp(u1,u2)
...
>>> sorted(['Bob','about','Zoo','Credit'],cmp_ignore_case)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: comparison function must return int, not NoneType
>>> def by_scort(t):
...     return t[1]
...
>>> L=[('Bob',75),('Adam',92),('Bart',66),('Lisa',88)]
>>> def by_scort(t):
...     return t[1]
...
>>> L1=sorted(L,key=by_scort,reverse=True)
>>> print(L1)
[('Adam', 92), ('Lisa', 88), ('Bob', 75), ('Bart', 66)]
>>> L=[('Bob',75),('Adam',92),('Bart',66),('Lisa',88)]
>>> def by_scort(t):
...     return t[0]
...
>>> L1=sorted(L,key=by_scort,reverse=True)
>>>
>>> print(L1)
[('Lisa', 88), ('Bob', 75), ('Bart', 66), ('Adam', 92)]
>>> L=[('Bob',75),('Adam',92),('Bart',66),('Lisa',88)]
>>> def by_scort(t):
...     return t[0]
...
>>> L1=sorted(L,key=by_scort)
>>> print(L1)
[('Adam', 92), ('Bart', 66), ('Bob', 75), ('Lisa', 88)]
>>> L=[('Bob',75),('Adam',92),('Bart',66),('Lisa',88)]
>>> def by_scort():
...     return t[1]
...
>>> L1=sorted(L,key=by_scort)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: by_scort() takes no arguments (1 given)
>>> L=[('Bob',75),('Adam',92),('Bart',66),('Lisa',88)]
>>> def by_scort(t):
...     return t[1]
...
>>> L1=sorted(L,key=by_scort)
>>> print(L1)
[('Bart', 66), ('Bob', 75), ('Lisa', 88), ('Adam', 92)]
>>> L=[('Bob',75,99),('Adam',92,44),('Bart',66,90),('Lisa',88,88)]
>>> def by_english(t):
...     return t[2]
...
>>> L2=sorted(L,key=by_english,reverse=True)
>>> print(L2)
[('Bob', 75, 99), ('Bart', 66, 90), ('Lisa', 88, 88), ('Adam', 92, 44)]
>>> def lazy_sum(*args)
  File "<stdin>", line 1
    def lazy_sum(*args)
                      ^
SyntaxError: invalid syntax
>>> def lazy_sum(*args):
...     def sum():
...         ax=0
...         for n in args:
...             ax=ax+n
...         return ax
...     return sum
...
>>> f=lazy_sum(1,3,5,7,9)
>>> f
<function sum at 0x029E2030>
>>> f()
25
>>> list(map(lambda x:x*x,[1,2,3,4,5,6,7,8,9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
>>> f=lambda x:x*x
>>> f(5)
25
>>> def f(x):
...     return x*x
...
>>> f(5)
25
>>> def build(x,y)
  File "<stdin>", line 1
    def build(x,y)
                 ^
SyntaxError: invalid syntax
>>> def build(x,y):
...     return lambda:x*x+y*y
...
>>> build(1,2)
<function <lambda> at 0x029E2070>
>>> def now():
...     print('2015-3-25')
...
>>> f=now
>>> f()
2015-3-25
>>> now._name_
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'function' object has no attribute '_name_'
>>> def now():
...     print('2015-3-25')
...
>>> now._name_
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'function' object has no attribute '_name_'
>>> f._name_
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'function' object has no attribute '_name_'
>>> def log(func):
...     def wrapper(*args,**kw):
...         print('call %s()' %func._name_)
...         return func(*args,**kw)
...     return wrapper
...
>>> @log
... def now():
...     print('2015-3-25')
...
>>> now()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in wrapper
AttributeError: 'function' object has no attribute '_name_'
>>> def int2(x,base=2):
...     return int(x,base)
...
>>> int2('1000000')
64
>>> import functools
>>> int2=functools.partial(int,base=2)
>>> int2('1000000')
64
>>> int2('100000',base=10)
100000
>>> class Student(object):
...
  File "<stdin>", line 2

    ^
IndentationError: expected an indented block
>>> class Student(object):
...       def _init_(self,name,score):
...           self.name=name
...           self.score=score
...       def print_score(self):
...
  File "<stdin>", line 6

    ^
IndentationError: expected an indented block
>>> class Student(object):
... pass
  File "<stdin>", line 2
    pass
       ^
IndentationError: expected an indented block
>>> class Student(object):
...       pass
...
>>> bart=Student()
>>> bart
<__main__.Student object at 0x029E51B0>
>>> Student
<class '__main__.Student'>
>>> bart.name='bart simpson'
>>> bart.name
'bart simpson'
>>> class Student(object):
...    def _init_(self,name,score):
...        self.name=name
...        self.score=score
...
>>> bart=Student('Bart Simpson',59)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: object.__new__() takes no parameters
>>>    def _init_(self,name,score):
  File "<stdin>", line 1
    def _init_(self,name,score):
    ^
IndentationError: unexpected indent
>>> class Student(object):
...    def __init__(self,name,score):
...        self.name=name
...        self.score=score
...
>>> bart=Student('Bart Simpson',59)
>>> bart.name
'Bart Simpson'
>>> bart.score
59